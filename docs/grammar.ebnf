
chunk                ::= statement* EOF

statement            ::= import_statement
                       | variable_declaration ';'
                       | assign_call ';'
                       | struct_declaration
                       | function_declaration
                       | delete_statement
                       | if_statement
                       | match_statement
                       | loop_statement
                       | while_statement
                       | for_statement
                       | break_statement
                       | return_statement
                       | block

import_statement     ::= 'import' NAME ( 'as' NAME )? ';'
                       | 'import' STRING 'as' NAME ';'
                       | 'import' '{' NAME ( ',' NAME )* '}' 'from' ( NAME | STRING ) ';'

variable_declaration ::= 'let' NAME '=' expression
                       | 'mut' NAME ( '=' expression )?
                       | ( 'let' | 'mut' ) '[' '_' | NAME ( ',' '_' | NAME )* ']' '=' expression
                       | ( 'let' | 'mut' ) '{' NAME ( ',' NAME )* '}' '=' expression

assign_call          ::= NAME subscript* assign_op expression
                       | NAME subscript* ( '++' | '--' )
                       | NAME subscript* '[' ']' '=' expression
                       | NAME subscript* subscript '=' expression
                       | NAME ( subscript | call )* call

struct_declaration   ::= 'struct' NAME '{' ( string | NAME ( ',' string | NAME )* )? '}'

function_declaration ::= 'fn' NAME '(' ( 'mut'? NAME ( ',' 'mut'? NAME )* )? ')' ( '=>' expression ";" | block )

delete_statement     ::= 'del' NAME subscript* '[' expression ']' ';'

if_statement         ::= ( 'if' | 'if!' ) '(' ( variable_declaration ';' )? expression ')'
                         statement ( 'else' statement )?

match_statement      ::= 'match' '(' ( variable_declaration ';' )? expression ')'
                         '{' ( expression '=>' statement )+ ( '_' '=>' statement )? '}'

loop_statement       ::= 'loop' statement

while_statement      ::= ( 'while' | 'while!' ) '(' expression ')' statement
                       | 'do' statement ( 'while' | 'while!' ) '(' expression ')' ';'

for_statement        ::= 'for' '(' ( variable_declaration | assign_call )? ';' expression? ';' assign_call? ')' statement
                       | 'foreach' '(' NAME 'in' expression ')' statement

break_statement      ::= ( 'break' | 'continue' ) ';'

return_statement     ::= 'return' expression? ';'

block                ::= '{' stmt* '}'

assign_op            ::= '=' | '|=' | '^=' | '&=' | '<<=' | '>>=' 
                       | '+=' | '-=' | '*=' | '/=' | '~/=' | '%='

subscript            ::= '[' expression ']' | '.' NAME

call                 ::= '(' ( expression ( ',' expression )* )? ')'

expression           ::= and_expression ( '||' and_expression )*

and_expression       ::= equal_expression ( '&&' equal_expression )*

equal_expression     ::= comp_expression ( ( '==' | '!=' ) comp_expression )*

comp_expression      ::= bor_expression ( ( '>' | '>=' | '<' | '<=' ) bor_expression )*

bor_expression       ::= bxor_expression ( '|' bxor_expression )*

bxor_expression      ::= band_expression ( '^' band_expression )*

band_expression      ::= shift_expression ( '&' shift_expression )*

shift_expression     ::= range_expression ( ( '<<' | '>>' ) range_expression )*

range_expression     ::= add_expression ( '..' add_expression )?

add_expression       ::= mul_expression ( ( '+' | '-' ) mul_expression )*

mul_expression       ::= unary_expression ( ( '*' | '/' | '~/' | '%' ) unary_expression )*

unary_expression     ::= ( '-' | '!' | '~' ) unary_expression | primary_expression

primary_expression   ::= literal
                       | array_constructor
                       | struct_constructor
                       | anonymous_struct
                       | anonymous_function
                       | if_expression
                       | match_expression
                       | subscript_call
                       | group_expression

literal              ::= 'nil' | 'false' | 'true' | number | string

array_constructor    ::= '[' ( expression ( ',' expression )* )? ']'

struct_constructor   ::= '{' ( string | NAME ':' expression ( ',' string | NAME ':' expression )* )? '}'

anonymous_struct     ::= 'struct' '{' ( string | NAME ( ',' string | NAME )* )? '}'

anonymous_function   ::= '|' ( 'mut'? NAME ( ',' 'mut'? NAME )* )? '|' ( '=>' expression | block )
                       | '||' ( '=>' expression | block )

if_expression        ::= ( 'if' | 'if!' ) '(' expression ')' expression 'else' expression

match_expression     ::= 'match' '(' expression ')' '{' expression '=>' expression ( ',' expression '=>' expression )*
                         ',' '_' '=>' expression '}'

subscript_call       ::= NAME ( subscript | call )* ( '{' ( expression ( ',' expression )* )? '}' )?

group_expression     ::= '(' expression ')'
